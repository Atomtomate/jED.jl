var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = jED","category":"page"},{"location":"#jED","page":"Home","title":"jED","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for jED.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [jED]","category":"page"},{"location":"#jED.AIM","page":"Home","title":"jED.AIM","text":"AIM <: Model\nAIM(ϵₖ::Vector{Float64}, Vₖ::Vector{T}, μ::Float64, U::Float64)\n\nType for the Anderson impurity model. A model can be used to construct a Eigenspace given a set of Basis.\n\nCan be created from \n\nbath onsite energies epsilon_k,\nbath-impurity hopping V_k\nimpurity chemical potential mu\nCoulomb interaction strength on the impurity U\n\nExample\n\njulia> ϵₖ = [0.5, -5.0]\njulia> Vₖ = [1.0, 1.0]\njulia> U  = 1.0\njulia> μ  = 0.5\njulia> model = AIM(ϵₖ, Vₖ, μ, U)\nAIM{3, Float64}([\n-0.5 1.0 1.0; 1.0 0.5 0.0; 1.0 0.0 -5.0], [1.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0], [0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0])\n\n\n\n\n\n","category":"type"},{"location":"#jED.Basis","page":"Home","title":"jED.Basis","text":"Basis\n\nA state is represented as a BitVetor of length 64. The first 32 bit (ordering follows Julia Vector indexing) correspond to spin up for each site (index 1 corresponds to the first site, 2 to the second, etc.) and bits 33 to 64 to spin down, for site 1 to 32. Each bit is set to 1 if it is occupied by an electron of the given spin. In principle, the number of electron flavors and orbitals is free, however, for now it is fixed to 2 and 1.\n\nA list of states should be generated using States(NSites) with NSites being the number of sites in the model.\n\nFields\n\nNFlavors  : Integer, number of flavors (TODO: hardcoded to 2 for now. later: orbitals*2?!)\nNSites    : Integer, number of sites\nstates    : Vector{State}, list of Fock states. The are sorted according to good quantum numbers. blocklist contains start and size of blocks.\nblocklist : Vector{NTuple{4,Int}}, Vector of 4-tuples. Each entry encodes a block in the following form: 1. element is the start index of the block, 2. element is the column size of the block, 3. element is the electron number (see N_el), 4. element is the spin (see S) \ncdag_ov   : Vector{Tuple{UnitRange{Int},UnitRange{Int}}}, Slices of states, that contribute to an overlap with one creation operator. Needed for performance reasons in computation of Lehmann representation (see also (@ref findcdagoverlapblocks)[_find_cdag_overlap_blocks])).\n\n\n\n\n\n","category":"type"},{"location":"#jED.Eigenspace","page":"Home","title":"jED.Eigenspace","text":"Eigenspace\n\nContaines Eigenvalues and Eigenvectors grouped into blocks with are each ordered by magnitude of Eigenvalues. The blocks are part of the Basis.\n\nFields\n\nevals     : Eigenvalues\nevecs     : Eigenvectors\nE0        : smallest Eigenvalue\n\n\n\n\n\n","category":"type"},{"location":"#jED.Eigenspace-Tuple{jED.Model, Basis}","page":"Home","title":"jED.Eigenspace","text":"Constructs Eigenspace for Model over given Basis by diagonalizing the Hamiltonian (see also calc_Hamiltonian) for each block.\n\n\n\n\n\n","category":"method"},{"location":"#jED.Model","page":"Home","title":"jED.Model","text":"Model\n\nAbstract type for model type.  Currently implemented:\n\nAIM\n\n\n\n\n\n","category":"type"},{"location":"#jED.Operator","page":"Home","title":"jED.Operator","text":"Operator\n\nOperator for Fockstates. Holds function for transformation of Fock state and change in quantum numbers.\n\nFields\n\nf        : Function, operation on Fock state\nN_inc    : Integer, change in electron number\nS_inc    : Integer, change in spin number\n\nExample\n\njulia> o1 = Operator(x->create())\n\n\n\n\n\n","category":"type"},{"location":"#jED.CDag_sign-Tuple{StaticArraysCore.SVector{Length, Bool} where Length, Int64}","page":"Home","title":"jED.CDag_sign","text":"CDag_sign(state,i)\n\nSign when annihilating an electron at position i in state. Returns: -1/1/0 for Uneven/Even permutations and 0 when the state is not occupied.\n\njulia> CDag_sign(Fockstate{6}(Bool[1,0,1,1,0,0]),5)\n-1\njulia> CDag_sign(Fockstate{6}(Bool[1,0,1,1,0,0]),3)\n0\njulia> CDag_sign(Fockstate{7}(Bool[1,0,1,0,1,0,0]),4)\n1\n\n\n\n\n\n","category":"method"},{"location":"#jED.C_sign-Tuple{StaticArraysCore.SVector{Length, Bool} where Length, Int64}","page":"Home","title":"jED.C_sign","text":"C_sign(state,i)\n\nSign when creating an electron at position i in state. Returns: -1/1/0 for Uneven/Even permutations and 0 when the state is not occupied.\n\njulia> C_sign(Fockstate{6}(Bool[1,0,1,1,0,0]),3)\n-1\njulia> C_sign(Fockstate{6}(Bool[1,0,1,1,0,0]),2)\n0\njulia> C_sign(Fockstate{6}(Bool[1,0,1,1,0,0]),4)\n\n\n\n\n\n","category":"method"},{"location":"#jED.N_do-Union{Tuple{StaticArraysCore.SVector{NSites, Bool}}, Tuple{NSites}} where NSites","page":"Home","title":"jED.N_do","text":"N_do(s::Fockstate{NSites})\n\nNumber of down electrons, N_downarrow in state s.\n\n\n\n\n\n","category":"method"},{"location":"#jED.N_el-Tuple{StaticArraysCore.SVector{Length, Bool} where Length}","page":"Home","title":"jED.N_el","text":"N_el(s::AbstractVector)::Int\n\nTotal electron number of state.\n\n\n\n\n\n","category":"method"},{"location":"#jED.N_up-Union{Tuple{StaticArraysCore.SVector{NSites, Bool}}, Tuple{NSites}} where NSites","page":"Home","title":"jED.N_up","text":"N_up(s::Fockstate{NSites})\n\nNumber of up electrons, N_uparrow in state s.\n\n\n\n\n\n","category":"method"},{"location":"#jED.S-Union{Tuple{StaticArraysCore.SVector{NSites, Bool}}, Tuple{NSites}} where NSites","page":"Home","title":"jED.S","text":"S(s::AbstractVector)::Int\n\nTotal spin of state. #TODO: only implemented for flavor=2\n\n\n\n\n\n","category":"method"},{"location":"#jED._H_CDagC-Tuple{StaticArraysCore.SVector{Length, Bool} where Length, StaticArraysCore.SVector{Length, Bool} where Length, StaticArraysCore.SMatrix}","page":"Home","title":"jED._H_CDagC","text":"_H_CDag_C(istate, jstate, tMatrix)\n\nReturns the hopping contribution for states sum_ij langle i  T  j rangle, with T being the hopping matrix tmatrix and the states i and j given by istate and jstate.\n\n\n\n\n\n","category":"method"},{"location":"#jED._H_nn-Tuple{StaticArraysCore.SVector{Length, Bool} where Length, StaticArraysCore.SVector{Length, Bool} where Length, StaticArraysCore.SMatrix}","page":"Home","title":"jED._H_nn","text":"_H_nn(istate, jstate, tMatrix)\n\nReturns the hopping contribution for states sum_ij langle i  T  j rangle, with T being the hopping matrix tmatrix and the states i and j given by istate and jstate.\n\n\n\n\n\n","category":"method"},{"location":"#jED._block_slice-Tuple{NTuple{4, Int64}}","page":"Home","title":"jED._block_slice","text":"_block_slice(bi::Blockinfo)\n\nSlice of continuous vector for given block bi.\n\n\n\n\n\n","category":"method"},{"location":"#jED._find_cdag_overlap_blocks-Tuple{Vector{NTuple{4, Int64}}, Operator}","page":"Home","title":"jED._find_cdag_overlap_blocks","text":"_find_cdag_overlap_blocks(blocklist::Vector{Blockinfo}; S_inc=-1, N_inc = 1)\n\nFind block index with N_el increased by 1 and S either in increased or decreased (depending on S_inc), e.g. block index of state langle j  with non-zero overlap of c^dagger_uparrow i rangle.\n\nReturns: Vector{Int}, equal length to blocklist. Each entry with index i contains the index j of the block with one more electron and spin (i.e. the block for which langle j c^dagger  i rangle does NOT vanish). This is stored here for performance reasons, since these overlaps are used often in the Lehman representation. TODO: do not hardcode spin up GF!!! (this forces S+1 instead of S+-1 for now)\n\n\n\n\n\n","category":"method"},{"location":"#jED._generate_blocks!-Union{Tuple{Array{StaticArraysCore.SVector{Length, Bool}, 1}}, Tuple{Length}} where Length","page":"Home","title":"jED._generate_blocks!","text":"_generate_blocks!(states::Vector{Fockstate})\n\nSort state list and generate list of blocks.\n\n\n\n\n\n","category":"method"},{"location":"#jED._overlap_cdagger_ev!-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Int64}}","page":"Home","title":"jED._overlap_cdagger_ev!","text":"_overlap_cdagger_ev!(tmp::Vector{Float64}, vec1::Vector{Float64}, vec2::Vector{Float64}, perm::Vector{Int})::Float64\n\nComputes langle textEV_j  c^dagger_k  textEV_i rangle where c^dagger has been computed in the Fockbasis and is given as a permutation of indices for langle textEV_j .\n\nThis is an internal function used to compute the overlaps.\n\n\n\n\n\n","category":"method"},{"location":"#jED._overlap_list-Tuple{Basis, Int64, Int64, Operator}","page":"Home","title":"jED._overlap_list","text":"overlaplist(basis::Basis[, i::Int, j::Int], op::Function)\n\nCalculates the overlap between block i and j under op. Builds full overlap indices for all block if i and j are not provided.\n\nExample\n\njulia> basis = jED.Basis(3)\njulia> op(b) = jED.create(b, 4)  # creation operator for spin down at site 1 of 3\njulia> jED._overlap_list(basis, 2, 4, op)\n[0, 1, 2]\n\n\n\n\n\n","category":"method"},{"location":"#jED.ann-Union{Tuple{Length}, Tuple{StaticArraysCore.SVector{Length, Bool}, Int64}} where Length","page":"Home","title":"jED.ann","text":"ann(state::Fockstate{Length}, i::Int)::Union{Nothing,Fockstate} where Length\n\nReturns either a new Fockstate with an electron i annihilated (see layout of Fockstate, how up and down is encoded), or nothing, if i is not occupied. See also create. See also ann_op for the Operator version.\n\n\n\n\n\n","category":"method"},{"location":"#jED.ann_op-Tuple{Basis, Int64}","page":"Home","title":"jED.ann_op","text":"anne_op(b::Basis, i::Int)\n\nOperator for annihilation of state i (for basis length N, i > N annihilates spin down, otherwise spin up).\n\n\n\n\n\n","category":"method"},{"location":"#jED.calc_E-Tuple{Eigenspace, Float64}","page":"Home","title":"jED.calc_E","text":"calc_E(eigenspace, β)\n\nCalculates the total energy from eigenspace and the inverse temperature β.\n\n\n\n\n\n","category":"method"},{"location":"#jED.calc_GF_1-Tuple{Basis, Eigenspace, Vector{ComplexF64}, Float64}","page":"Home","title":"jED.calc_GF_1","text":"calc_GF_1(es::Eigenspace, freq::ComplexF64, β::Float64)\n\nComputes langle i  c^dagger  j rangle^2 frace^-beta E_i + e^-beta E_jZ (E_j - E_i + freq). TODO: not tested\n\n\n\n\n\n","category":"method"},{"location":"#jED.calc_Hamiltonian-Union{Tuple{NSites}, Tuple{jED.Model, Array{StaticArraysCore.SVector{NSites, Bool}, 1}}} where NSites","page":"Home","title":"jED.calc_Hamiltonian","text":"calc_Hamiltonian(model::Model, basis::Basis)\n\nCalculates the Hamiltonian for a given \n\nmodel, see for example AIM)) in a \nbasis, see Basis  \n\n\n\n\n\n","category":"method"},{"location":"#jED.calc_Z-Tuple{Eigenspace, Float64}","page":"Home","title":"jED.calc_Z","text":"calc_Z(eigenspace, β)\n\nCalculates the partition function from eigenspace and the inverse temperature β.\n\n\n\n\n\n","category":"method"},{"location":"#jED.create-Union{Tuple{Length}, Tuple{StaticArraysCore.SVector{Length, Bool}, Int64}} where Length","page":"Home","title":"jED.create","text":"create(state::Fockstate{Length}, i::Int)::Union{Nothing,Fockstate} where Length\n\nReturns either a new Fockstate with an electron i created (see layout of Fockstate, how up and down is encoded), or nothing, if i is already occupied. See also ann. See also create_op for the Operator version.\n\n\n\n\n\n","category":"method"},{"location":"#jED.create_op-Tuple{Basis, Int64}","page":"Home","title":"jED.create_op","text":"create_op(b::Basis, i::Int)\n\nOperator for creation of state i (for basis length N, i > N creates spin down, otherwise spin up).\n\n\n\n\n\n","category":"method"},{"location":"#jED.operator_ni-Tuple{StaticArraysCore.SVector{Length, Bool} where Length, Int64}","page":"Home","title":"jED.operator_ni","text":"operator_ni(state::Fockstate, i::Int)\n\nCalculate n_i |ket⟩, i.e. i is the index for the number operator\n\nReturns: (eigenval,newState)::Tuple{Int, Fockstate} with eigenval 1 (state i occupied) or 0 (state i unoccupied) and newState. In case of this operator, newState === state. The density overlap of 2 states can be calculated efficiently using overlap_ni_nj.\n\nExample\n\njulia> jED.operator_ni(jED.SVector{8}(Bool[1,1,1,1,0,1,0,1]), 2);\n(1, Bool[1, 1, 1, 1, 0, 1, 0, 1])\n\n\n\n\n\n","category":"method"},{"location":"#jED.overlap-Tuple{StaticArraysCore.SVector{Length, Bool} where Length, StaticArraysCore.SVector{Length, Bool} where Length}","page":"Home","title":"jED.overlap","text":"overlap(bra::Fockstate, ket::Fockstate)\n\nCalculates ⟨bra|ket⟩. This is useful when operators have been applied to one state and no efficient direct implementation for an overlap involving this operator is available.\n\nReturns: True/False\n\n\n\n\n\n","category":"method"},{"location":"#jED.overlapMatrix-Tuple{Eigenspace, Int64}","page":"Home","title":"jED.overlapMatrix","text":"overlapMatrix(es::Eigenspace, ket_block_index::Int)::Matrix{Float64}\n\nComputes ``|\\langle i | c^\\dagger | j \\rangle|^2. TODO: not used for now, probably usefull for 2-particle GF.\n\n\n\n\n\n","category":"method"},{"location":"#jED.overlap_2-Tuple{Vector{ComplexF64}, Vector{ComplexF64}}","page":"Home","title":"jED.overlap_2","text":"overlap_2(bra::Vector, ket::Vector)\n\nComputes |⟨bra|ket⟩|² for Float64 or ComplexF64 type vectors.\n\n\n\n\n\n","category":"method"},{"location":"#jED.overlap_cdagger-Tuple{Basis, Eigenspace, Vector{Int64}}","page":"Home","title":"jED.overlap_cdagger","text":"\n\n\n\n","category":"method"},{"location":"#jED.overlap_cdagger_c-Tuple{StaticArraysCore.SVector{Length, Bool} where Length, Int64, StaticArraysCore.SVector{Length, Bool} where Length, Int64}","page":"Home","title":"jED.overlap_cdagger_c","text":"overlap_cdagger_c(bra::Fockstate, i::Int, ket::Fockstate, j::Int)::Int\n\nCalculates langle bra  c^dagger_i c_j  ket rangle, i.e. i is the index for the creation operator and j the index for the annihilation operator. Internally, we check, that both states have exactly two or no occupation difference. In both cases the product of C_sign and CDag_sign is returned, otherwise 0. Note, that this allows spin flips!\n\nReturns: -1/0/1\n\nExample\n\njulia> t1 = jED.SVector{8}(Bool[1,1,1,1,0,1,0,1]);\njulia> t2 = jED.SVector{8}(Bool[1,1,0,1,1,1,0,1]);\njulia> jED.overlap_cdagger_c(t1,t2,3,3)\n0\njulia> jED.overlap_cdagger_c(t1,t1,2,2)\n1\n\n\n\n\n\n","category":"method"},{"location":"#jED.overlap_ni_nj-Tuple{StaticArraysCore.SVector{Length, Bool} where Length, StaticArraysCore.SVector{Length, Bool} where Length, Int64, Int64}","page":"Home","title":"jED.overlap_ni_nj","text":"overlap_ni_nj(bra::Fockstate, ket::Fockstate, i::Int, j::Int)\n\nCalculate ⟨bra| n^†i nj |ket⟩\n\nReturns: True/False (converts to 1/0)\n\n\n\n\n\n","category":"method"}]
}
